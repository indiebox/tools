#!/usr/bin/perl -CSD
#
# Take the web traffic recording made by proxycord and
# generate a webapptest test file.
#
# Copyright (C) 2018 and later, Indie Computing Corp. All rights reserved. License: see package.
#

use strict;
use warnings;

use Getopt::Long;
use POSIX qw(strftime);
use UBOS::Logging;
use UBOS::Utils;

my $verbose           = 0;
my $logConfigFile     = undef;
my $debug             = undef;
my $hostname          = undef;
my $context           = "";
my $in                = undef;
my $out               = undef;
my $help              = 0;

my $parseOk = GetOptions(
    'verbose+'        => \$verbose,
    'logConfig=s'     => \$logConfigFile,
    'debug'           => \$debug,
    'hostname=s'      => \$hostname,
    'context=s'       => \$context,
    'in=s'            => \$in,
    'out=s'           => \$out,
    'help'            => \$help );

if( $help ) {
    synopsisHelpQuit( 1 );
}
if(    !$parseOk
    || !$hostname
    || ( $context && $context !~ m!^/! )
    || !$in
    || !$out )
{
    synopsisHelpQuit();
}

UBOS::Logging::initialize( 'webapptest-create', undef, $verbose, $logConfigFile, $debug );

my $json = UBOS::Utils::readJsonFromFile( $in );
unless( $json ) {
    fatal( 'Failed to read JSON recording:', $! );
}

my $now = now();
my $content = <<END;
#
# webapptest file, generated by webapptest-create on $now
#
# EDITING REQUIRED BEFORE THIS RUNS. Must-change values are marked with ???
#

use strict;
use warnings;

# package ???;

use UBOS::WebAppTest;

my \$TEST = UBOS::WebAppTest->new(
    appToTest   => '???',
    accessoriesToTest => [
            '???',
            '???',
            '???'
    ],
    description => '???',
    checks      => [
END

foreach my $step ( @{$json->{steps}} ) {
    if( !exists( $step->{type} )) {
        warning( 'No type entry on JSON element, skipping' );
        next;
    }

    my $stepType = $step->{type};
    my $stepName = $step->{name} || '???';

    trace( 'Processing step', $stepType, ':', $stepName );

    if( 'mark' eq $stepType ) {
        $content .= <<END
# Mark: $stepName
END

    } elsif( 'HttpRequestResponse' eq $stepType ) {
        $content .= <<END;
            UBOS::WebAppTest::StateCheck->new(
                    name  => '$stepName',
                    check => sub {
            # UBOS::WebAppTest::StateTransition->new(
            #         name  => '$stepName',
            #         transition => sub {

                        my \$c = shift;
END
        $content .= convertHttpRequestResponseStep( $step );
        $content .= <<END;
                        return 1;
                    }
            ),
END

    } else {
        $content .= <<END
# Unknown step type: $stepType
END
    }
}

$content .= <<END;
    ]
);

\$TEST;
END

UBOS::Utils::saveFile( $out, $content );

#####
# The meat of the program. Convert a recorded HttpRequestResponse step
# into some Perl that reproduces the execution.
# $step: the JSON step
# return: the Perl
sub convertHttpRequestResponseStep {
    my $step = shift;

    my $request      = $step->{request};
    my $response     = $step->{response};

    my $verb         = $request->{verb};
    my $relativePath = $request->{path};
    if( $context ) {
        if( $relativePath =~ m!^$context(.*)$! ) {
            $relativePath = $1;
        } else {
            warning( 'Recorded relative URL', $relativePath, 'does not start with stated context', $context );
        }
    }

    my $status  = $response->{status};

    my $ret = "# Cannot convert HTTP $verb $relativePath with status $status\n";
    
    if( $verb eq 'GET' ) {
        if( $status == 304 ) {
            # skip, not interesting
        
        } elsif( $status == 301 || $status == 302 || $status == 303 || $status eq 307 || $status eq 308 ) {
            my $location = relativizeUrl( $response->{headers}->{Location}[0] );

            $ret = <<PERL;
                        \$c->getMustRedirect( '$relativePath', '$location', $status, 'Not redirecting correctly' );
PERL

        } else {
            if( exists( $response->{contentastext} )) {
                my $escapedContent = perlEscapeContent( $response->{contentastext} );

                $ret = <<PERL;
                        \$c->getMustBe( '$relativePath', <<'CONTENT', $status, 'Wrong content at $relativePath' );
$escapedContent
CONTENT
PERL
            } else {
            
                my $rawContentLength = $response->{rawcontentlength};

                $ret = <<PERL;
                        \$c->getMustHaveLength( '$relativePath', $rawContentLength, $status, 'Wrong length' );
PERL
            }
        }
    } # else FIXME

    return $ret;
}

#####
# Turn arbitrary data and turn it into something that is an equivalent
# Perl heredoc's content
# $raw: the data
# return: suitably escaped
sub perlEscapeContent {
    my $data = shift;

    return $data;
}

#####
# Given a URL, turn it into a relative URL to the context of this app
# $url: the URL
# return: relative URL
sub relativizeUrl {
    my $url = shift;

    if( $url =~ m!^(https?)://([^/]+)((/[^/]*)(/.*)?)?$! ) {
        my $foundContext = $4;
        my $relativeUrl  = $5;
        if( $foundContext eq $context ) {
            return $relativeUrl;
        }
    }
    return $url;
}

#####
# Construct a time stamp
sub now {
    my $now = time;
    return strftime( "%Y/%m/%d-%H:%M:%S", gmtime( $now ));
}

#####
sub synopsisHelpQuit {
    my $long = shift || 0;

    if( $long ) {
        print <<END;
Synopsis:
    webapptest-create ...
        ...

    webapptest-create --help
        This help text.

Optional flags:
    --in <file>
        JSON file that has the recording
    --out <file>
        Save test to this file.
    --verbose
        More output
    --logConfig <file>
        Use the specified logging config file
    --debug
        Enter debug mode
END
    } else {
        print <<END;
webapptest-create --in <file> --out <file> --hostname <hostname> ... [--verbose]
END
    }
    exit 0;
}

1;
