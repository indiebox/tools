#!/usr/bin/perl
#
# Run a proxy in front of a website. Record traffic and save it suitably
# for webapptest to run as test cases.
#
# Copyright (C) 2018 and later, Indie Computing Corp. All rights reserved. License: see package.
#

use strict;
use warnings;

use File::Temp qw(:POSIX);
use Getopt::Long;
use IO::Select;
use IO::Socket::INET;
use POSIX qw(strftime);
use Time::HiRes qw(time);
use UBOS::Logging;
use UBOS::Utils;

my $verbose           = 0;
my $logConfigFile     = undef;
my $debug             = undef;
my $localHost         = '0.0.0.0';
my $localPort         = 80;
my $remotePort        = undef;
my $remoteHost        = undef;
my $out               = undef;
my $help              = 0;

my $parseOk = GetOptions(
    'verbose+'        => \$verbose,
    'logConfig=s'     => \$logConfigFile,
    'debug'           => \$debug,
    'local-host=s'    => \$localHost,
    'local-port=s'    => \$localPort,
    'remote-host=s'   => \$remoteHost,
    'remote-port=s'   => \$remotePort,
    'out=s'           => \$out,
    'help'            => \$help );

if( $help ) {
    synopsisHelpQuit( 1 );
}
if(    !$parseOk
    || !$remoteHost )
{
    synopsisHelpQuit();
}

unless( $remotePort ) {
    $remotePort = $localPort;
}

UBOS::Logging::initialize( 'webapptest-record', undef, $verbose, $logConfigFile, $debug );

info( 'Listening on', "$localHost:$localPort => $remoteHost:$remotePort" );
info( 'Hit return to quit.' );

my $localSocket = IO::Socket::INET->new(
        LocalAddr => $localHost,
        LocalPort => $localPort,
        Listen    => 10 );

unless( $localSocket ) {
    fatal( "Unable to listen on $localHost:$localPort: $!" );
}

my $ioset = IO::Select->new;
$ioset->add( \*STDIN );
$ioset->add( $localSocket );

# Only support a single connection
my $clientSocket;
my $serverSocket;

my $currentRequestData;
my $currentResponseData;

my @requests = ();
my @responses = ();

my $done = 0;
while( !$done ) {
    for my $socket( $ioset->can_read ) {
        my $buffer;
        my $read;

        if( $socket == \*STDIN ) {
            $read = $socket->sysread( $buffer, 4096 );
            $done = 1;
            last;

        } elsif( $socket == $localSocket ) {
            unless( $serverSocket ) {
                # accept the connection, but one connection only at a time
                # accept the connection
                $serverSocket = $localSocket->accept;
                $clientSocket = IO::Socket::INET->new(
                        PeerAddr => $remoteHost,
                        PeerPort => $remotePort );
                unless( $clientSocket ) {
                    fatal( "Unable to connect to $remoteHost:$remotePort: $!" );
                }
                $ioset->add( $clientSocket );
                $ioset->add( $serverSocket );
            }

        } else {
            if( $socket == $serverSocket ) {
                $read = $serverSocket->sysread( $buffer, 4096 );
                if( $read ) {
                    logRequestData( $buffer );
                    $clientSocket->syswrite( $buffer );
                }
            } else {
                $read = $clientSocket->sysread( $buffer, 4096 );
                if( $read ) {
                    logResponseData( $buffer );
                    $serverSocket->syswrite( $buffer );
                }
            }
            unless( $read ) {
                $ioset->remove( $clientSocket );
                $ioset->remove( $serverSocket );
                $clientSocket->close;
                $serverSocket->close;
                $clientSocket = undef;
                $serverSocket = undef;
            }
        }
    }
}

my $max = @requests;
if( @requests < @responses ) {
    warning( 'Fewer requests logged than responses:', scalar( @requests ), 'vs', scalar( @responses ));
} elsif( @requests < @responses ) {
    warning( 'more requests logged than responses:', scalar( @requests ), 'vs', scalar( @responses ));
    $max = @responses;
}
my $json = {};
$json->{steps} = [];
for( my $i=0 ; $i<$max ; ++$i ) {
    push @{$json->{steps}}, {
        'request' => $requests[$i],
        'response' => $responses[$i],
    };
}
if( $out ) {
    UBOS::Utils::writeJsonToFile( $out, $json );
} else {
    UBOS::Utils::writeJsonToStdout( $json );
}

END {
    if( $clientSocket ) {
        $ioset->remove( $clientSocket );
        $clientSocket->close;
    }
    if( $clientSocket ) {
        $ioset->remove( $serverSocket );
        $serverSocket->close;
    }
}

#####
# Some request data has been received
# $data: the data
sub logRequestData {
    my $data = shift;

    $currentRequestData .= $data;
    parseRequestData();
}

#####
# Some response data has been received
# $data: the data
sub logResponseData {
    my $data = shift;

    $currentResponseData .= $data;
    parseResponseData();
}


#####
# Data has been added to the request data buffer. Let's try to find
# a full request.
sub parseRequestData {
    while( 1 ) {
        if( $currentRequestData !~ m!(.*?)\r\n\r\n! ) {
            # don't have a full set of headers yet
            return;
        }
        unless( $currentRequestData =~ m!^([A-Z]+) ([^\s]+) HTTP/([\d\.]+)\r\n(.*?)\r\n\r\n(.*)$!s ) {
            fatal( 'Not a valid HTTP request:', $currentRequestData );
        }
        my $request = {};
        $request->{verb}    = $1;
        $request->{path}    = $2;
        $request->{version} = $3;
        map { my( $key, $value ) = split( /: /, $_, 2 ); $request->{headers}->{$key} = $value } split( /\r\n/, $4 );
        my $remainder       = $5;

        my $now = time;
        $request->{when} = strftime( "%Y/%m/%d-%H:%M:%S", gmtime( $now )) . sprintf( ".%03d", ( $now * 1000 ) % 1000 );

        if( !exists( $request->{headers}->{'Content-Length'} )) {
            push @requests, $request;
            $currentRequestData = $remainder;
        } else {
            my $contentLength = $request->{headers}->{'Content-Length'};
            if( length( $remainder ) >= $contentLength ) {
                $request->{content} = substr( $remainder, 0, $contentLength );
                push @requests, $request;
                $currentRequestData = substr( $remainder, $contentLength );
            }
        }
    }
}

#####
# Data has been added to the response data buffer. Let's try to find
# a full response.
sub parseResponseData {
    while( 1 ) {

        if( $currentResponseData !~ m!(.*?)\r\n\r\n! ) {
            # don't have a full set of headers yet
            return;
        }
        unless( $currentResponseData =~ m!^HTTP/([\d\.]+) (\d+) (.*?)\r\n(.*?)\r\n\r\n(.*)$!s ) {
            fatal( 'Not a valid HTTP response:', $currentResponseData );
        }
        my $response = {};
        $response->{version}    = $1;
        $response->{status}     = $2;
        $response->{statusText} = $3;
        map { my( $key, $value ) = split( /: /, $_, 2 ); $response->{headers}->{$key} = $value } split( /\r\n/, $4 );
        my $remainder           = $5;

        my $now = time;
        $response->{when} = strftime( "%Y/%m/%d-%H:%M:%S", gmtime( $now )) . sprintf( ".%03d", ( $now * 1000 ) % 1000 );

        if( !exists( $response->{headers}->{'Content-Length'} )) {            
            push @responses, $response;
            $currentResponseData = $remainder;
        } else {
            my $contentLength = $response->{headers}->{'Content-Length'};
            if( length( $remainder ) >= $contentLength ) {
                $response->{content} = substr( $remainder, 0, $contentLength );
                push @responses, $response;
                $currentResponseData = substr( $remainder, $contentLength );
            }
        }
    }
}

#####
sub synopsisHelpQuit {
    my $long = shift || 0;

    print <<END;
webapptest-record ...
END
    
    if( $long ) {
        print <<END;
Synopsis: webapptest-record ...
END
    }
    exit 0;
}
