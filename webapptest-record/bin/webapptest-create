#!/usr/bin/perl
#
# Take the web traffic recording made by webapptest-record and
# generate a webapptest test file.
#
# Copyright (C) 2018 and later, Indie Computing Corp. All rights reserved. License: see package.
#

use strict;
use warnings;

use Getopt::Long;
use POSIX qw(strftime);
use UBOS::Logging;
use UBOS::Utils;

my $verbose           = 0;
my $logConfigFile     = undef;
my $debug             = undef;
my $hostname          = undef;
my $context           = "";
my $in                = undef;
my $out               = undef;
my $help              = 0;

my $parseOk = GetOptions(
    'verbose+'        => \$verbose,
    'logConfig=s'     => \$logConfigFile,
    'debug'           => \$debug,
    'hostname=s'      => \$hostname,
    'context=s'       => \$context,
    'in=s'            => \$in,
    'out=s'           => \$out,
    'help'            => \$help );

if( $help ) {
    synopsisHelpQuit( 1 );
}
if(    !$parseOk
    || !$hostname
    || ( $context && $context !~ m!^/! )
    || !$in
    || !$out )
{
    synopsisHelpQuit();
}

UBOS::Logging::initialize( 'webapptest-create', undef, $verbose, $logConfigFile, $debug );

my $json = UBOS::Utils::readJsonFromFile( $in );
unless( $json ) {
    fatal( 'Failed to read JSON recording:', $! );
}

my $now = now();
my $content = <<END;
#
# webapptest file, generated by webapptest-record on $now
#
# EDITING REQUIRED BEFORE THIS RUNS. Required values are marked with ???
#

use strict;
use warnings;

# package ???;

use UBOS::WebAppTest;

my \$TEST = UBOS::WebAppTest->new(
    appToTest   => '???',
    accessoriesToTest => [
            '???',
            '???',
            '???'
    ],
    description => '???',
    checks      => [
END

my $status = undef;

foreach my $step ( @{$json->{steps}} ) {
    if( !exists( $step->{type} )) {
        warning( 'No type entry on JSON element, skipping' );
        next;
    }
    if( 'state' eq $step->{type} ) {
        if( $status ) {
            $content .= <<END;
                        return 1;
                    }
            ),
END
        }
        $status = $step->{type};
        my $currentName = $step->{name} || '???';

        $content .= <<END;
            UBOS::WebAppTest::StateCheck->new(
                    name  => '$currentName',
                    check => sub {
                        my \$c = shift;
END
    } elsif( 'transition' eq $step->{type} ) {
        if( $status ) {
            $content .= <<END;
                        return 1;
                    }
            ),
END
        }
        $status = $step->{type};
        my $currentName = $step->{name} || '???';

        $content .= <<END;
            UBOS::WebAppTest::StateTransition->new(
                    name  => '$currentName',
                    transition => sub {
                        my \$c = shift;
END
    } else {
        $content .= convertStep( $step );
    }
}
if( $status ) {
    $content .= <<END;
                        return 1;
                    }
            )
END
}

$content .= <<END;
    ]
);

\$TEST;
END

UBOS::Utils::saveFile( $out, $content );

#####
# The meat of the program. Convert a recorded step into some Perl
# that reproduces the execution.
# $step: the JSON step
# return: the Perl
sub convertStep {
    my $step = shift;

    my $request      = $step->{request};
    my $response     = $step->{response};

    my $verb         = $request->{verb};
    my $relativePath = $request->{path};
    if( $context ) {
        if( $relativePath =~ m!^$context(.*)$! ) {
            $relativePath = $1;
        } else {
            warning( 'Recorded relative URL', $relativePath, 'does not start with stated context', $context );
        }
    }

    my $status  = $response->{status};

    my $ret = "# Cannot convert HTTP $verb $relativePath with status $status\n";
    
    if( $verb eq 'GET' ) {
        if( $status =~ m!^3! ) {

        } else {
            my $escapedContent = perlEscapeContent( $response->{content} );

            $ret = <<PERL
                       \$c->getMustContain( '$relativePath', <<'CONTENT', $status, 'Wrong content at $relativePath' );
$escapedContent
CONTENT
PERL
        }
    } # else FIXME

    return $ret;
}

#####
# Turn arbitrary data and turn it into something that is an equivalent
# Perl heredoc's content
# $raw: the data
# return: suitably escaped
sub perlEscapeContent {
    my $data = shift;

    return $data;
}

#####
# Construct a time stamp
sub now {
    my $now = time;
    return strftime( "%Y/%m/%d-%H:%M:%S", gmtime( $now ));
}

#####
sub synopsisHelpQuit {
    my $long = shift || 0;

    if( $long ) {
        print <<END;
Synopsis:
    webapptest-create ...
        ...

    webapptest-create --help
        This help text.

Optional flags:
    --in <file>
        JSON file that has the recording
    --out <file>
        Save test to this file.
    --verbose
        More output
    --logConfig <file>
        Use the specified logging config file
    --debug
        Enter debug mode
END
    } else {
        print <<END;
webapptest-create --in <file> --out <file> ... [--verbose]
END
    }
    exit 0;
}

1;
